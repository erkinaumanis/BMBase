#!/bin/sh
#
prog=bmupdate
usage="$prog host"
#
#	Create updated database files using all the raw data in $HOME/BM/<host>/raw.
#	Files are updated in $HOME/BM/db


case $# in
1)	host="$1";	shift;;
*)	echo "usage: $usage" 1>&2
	exit 1
esac

DIR=$HOME/BM/$host

if [ ! -d $DIR/raw ]
then
	echo "$prog: `hostname -s`: dir '$DIR/raw' missing, aborted" 1>&2
	exit 2
fi

(cd $DIR
	mkdir -p db 2>/dev/null

	# why /dev/null?  so grep will include the file names, even if only one file	
	grep . /dev/null raw/2*	|	# all the readings files, with their paths
	sed 's;^.*/;;'	|	# remove leading path elements
	sed 's/:/ /'	|	# remove colon after the file name, which is also the time stamp
	awk -v OFS='	' '
	$2 ~ /RX|TX/	{
		date = $1
		type = $2
		pkts = $4
		bytes = $6
		fn = "db/" type
		print	date, pkts, bytes >fn
		next
	}  
	
	/^2.*/ {
		date=$1
		name = toupper($2)
		type = $3
		if (type != "scale" && type != "sensor") {
			print "bad type: $0" >"/dev/stderr"
			next
		}
		ver = $4
		batt = $5
		temp = $6
		hum = $7
		# (there is more: weight, and data in the device)
		sub(/%/, "", batt)
		sub(/F/, "", temp)
		sub(/%/, "", hum)
		fn = "db/" name
		if (type == "scale") {
			w = $10 + $11
			print date, batt, temp, hum, w >fn
		} else {
			print date, batt, temp, hum >fn
		}
		next
	}'

	# we may have multiple lines for TX and RX entries for each reading.
	# go through and pick the largest one
	for i in db/RX db/TX
	do
		awk <$i >$i.new -v OFS='	' '
		BEGIN {	pkts = bytes = 0 }
		$1 != last && (last != "") {
			print last, pkts, bytes
			pkts = bytes = 0
		}
		{	last = $1
			if ($2 > pkts)
				pkts = $2
			if ($3 > bytes)
				bytes = $3
		}
		END {	if (last != "")
				print last, pkts, bytes
		}' && mv $i.new $i || exit 99
	done
)

bmplotg $host /tmp/$host.png

if [ -d /web/hives ]
then
	cp /tmp/$host.png /web/hives/$host.png &&
		rm /tmp/$host.png
fi
